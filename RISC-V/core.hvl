(setq *transport-delay* 1)
(make-prologue)

(defvar *start-addr* #x0)
(defmacro start-addr ()
    `(write ,*start-addr*))

(use mems)
(make-mem imem 32 "file.hex" :input-format h :n-words 3 :buf-delay 1)

(module core
  ((input clk)
   (input rst)

   (output (32 iaddr))
   (input (32 inst))

   (output exit))

  (reg (32 pc))
  (reg (32 (32 regfile)))

  ;----------------------------------------------------------------
  (assign iaddr pc)
  (wire (5 rs1_addr))
  (wire (5 rs2_addr))
  (wire (5 wb_addr))

  (assign rs1_addr (ref inst 19 5))
  (assign rs2_addr (ref inst 24 20))
  (assign wb_addr (ref inst 11 7))

  (wire (32 rs1_data))
  (wire (32 rs2_data))
  (assign rs1_data (? (== rs1_addr 0) (ref regfile rs1_addr) 0))
  (assign rs2_data (? (== rs2_addr 0) (ref regfile rs2_addr) 0))

  (always ((posedge clk))
    (if rst
        (<= pc 0)
        (progn
           
          (display "pc:%h" pc)
          (display "inst:%h" inst)
          (display "rs1_addr:%d" rs1_addr)
          (display "rs2_addr:%d" rs2_addr)
          (display "wb_addr:%d" wb_addr)
          (display "rs1_data:%x" rs1_data)
          (display "rs2_data:%x" rs2_data)
          (display "-----------------------")

          (if (== pc 12)
            (finish))
            
          (<= pc (+ pc 4))))))

(module top ()
  (reg clk rst)
  (wire exit)
  (wire (32 addr inst))

  (always ()
    (# 5)
    (= clk (! clk)))

  (core :name core0 clk rst addr inst exit)
  (imem :name imem0 inst (>> addr 2))

  (always ((posedge clk))
    (if (== rst 0)
     (display "%t %x:%x" (time) addr inst)))
    
  (integer i j)
  (initial
    (= clk 0)

    (dumpfile "core.vcd")
    (dumpvars 0 core0)
    (dumpvars 0 imem0)
    (dumpvars 0 addr)
    (dumpvars 0 inst)

    (for (i 0) (< i 3) (i (+ i 1))
        (display "%d:%x" i (ref imem0.data i))
    )
    (delay 200)
    (= rst 0)

    (delay 200)
    (= rst 1)

    (delay 200)
    (= rst 0)

    (delay 200)

    (delay 3000)
    (finish)))
    
