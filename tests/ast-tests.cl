;;;; tests/ast-tests.cl — AST emit tests for verilisp Phase 1a
;;;; Each test builds a hand-written AST, emits it, and compares to expected output.

(defun run-ast-tests ()
  (let ((successes 0)
        (failures 0))

    (flet ((run-one (name ast-nodes expected)
             (let ((actual (emit-ast-to-string ast-nodes)))
               (if (string= actual expected)
                   (progn
                     (format t "Success:~c~a~%" #\Tab name)
                     (incf successes))
                   (progn
                     (format t "Failure:~c~a~%" #\Tab name)
                     ;; Find first difference
                     (let ((len (min (length actual) (length expected))))
                       (dotimes (i len)
                         (when (char/= (char actual i) (char expected i))
                           (format t "    first diff at position ~a~%" i)
                           (format t "    expected: ...~a...~%"
                                   (subseq expected (max 0 (- i 20)) (min (length expected) (+ i 40))))
                           (format t "    actual:   ...~a...~%"
                                   (subseq actual (max 0 (- i 20)) (min (length actual) (+ i 40))))
                           (return)))
                       (when (/= (length actual) (length expected))
                         (format t "    length mismatch: expected ~a, got ~a~%"
                                 (length expected) (length actual))
                         (let ((minl (min (length actual) (length expected))))
                           (format t "    expected tail: ~s~%"
                                   (subseq expected (max 0 (- minl 30))))
                           (format t "    actual tail:   ~s~%"
                                   (subseq actual (max 0 (- minl 30)))))))
                     (incf failures))))))

      ;; ================================================================
      ;; Test 1: declarators
      ;; ================================================================
      (run-one "declarators"
        (list
          ;; Wrapped in _$_ module (params=nil)
          '(:module _$_ nil
            (:reg a)
            (:reg (8 aa))
            (:reg (8 (4 ax)))
            (:reg (8 (4 aaa aab) ab) aba)
            (:wire b)
            (:wire (3 bb))
            (:wand c)
            (:wor d)
            (:integer e ee (4 eee))
            (:parameter ff 8)
            (:parameter ffg 9)
            (:trireg g)
            (:reg= x 4)
            (:reg= x0 (:+ 5 4))
            (:reg= x1 (:+ ff 4))
            (:reg (ff ffaa))
            (:reg ((:+ 3 4) ffab))
            (:reg= x2 (:h 8 #xfe))
            (:reg= (8 y) (:h 8 #xfe))
            (:reg (3 HD_valid_r))))
        (concatenate 'string
(format nil "~%module _$_;~%")
(format nil "    reg a;~%")
(format nil "    reg [7 : 0] aa;~%")
(format nil "    reg [7 : 0] ax [3 : 0];~%")
(format nil "    reg [7 : 0] aaa [3 : 0];~%")
(format nil "    reg [7 : 0] aab [3 : 0];~%")
(format nil "    reg [7 : 0] ab;~%")
(format nil "    reg aba;~%")
(format nil "    wire b;~%")
(format nil "    wire [2 : 0] bb;~%")
(format nil "    wand c;~%")
(format nil "    wor d;~%")
(format nil "    integer e;~%")
(format nil "    integer ee;~%")
(format nil "    integer eee [3 : 0];~%")
(format nil "    parameter ff = 8;~%")
(format nil "    parameter ffg = 9;~%")
(format nil "    trireg g;~%")
(format nil "    reg x = 4;~%")
(format nil "    reg x0 = (5 + 4);~%")
(format nil "    reg x1 = (ff + 4);~%")
(format nil "    reg [(ff - 1) : 0] ffaa;~%")
(format nil "    reg [((3 + 4) - 1) : 0] ffab;~%")
(format nil "    reg x2 = 8'hfe;~%")
(format nil "    reg [7 : 0] y = 8'hfe;~%")
(format nil "    reg [2 : 0] HD_valid_r;~%")
"endmodule" (string #\Newline)))

      ;; ================================================================
      ;; Test 2: case
      ;; ================================================================
      (run-one "case"
        (list
          '(:module _$_ nil
            (:case a
              (1 (:$ display 1))
              (2 (:$ display 2))
              (default (:$ display 0)))
            (:casex b
              (1 (:$ display 1))
              (2 (:$ display 2))
              (default (:$ display 0)))
            (:casez c
              (1 (:$ display 1))
              (2 (:$ display 2))
              (default (:$ display 0)))))
        (concatenate 'string
(format nil "~%module _$_;~%")
(format nil "    case(a)~%")
(format nil "        1:~%")
(format nil "            $display(1);~%")
(format nil "        2:~%")
(format nil "            $display(2);~%")
(format nil "        default:~%")
(format nil "            $display(0);~%")
(format nil "    endcase~%")
(format nil "    casex(b)~%")
(format nil "        1:~%")
(format nil "            $display(1);~%")
(format nil "        2:~%")
(format nil "            $display(2);~%")
(format nil "        default:~%")
(format nil "            $display(0);~%")
(format nil "    endcase~%")
(format nil "    casez(c)~%")
(format nil "        1:~%")
(format nil "            $display(1);~%")
(format nil "        2:~%")
(format nil "            $display(2);~%")
(format nil "        default:~%")
(format nil "            $display(0);~%")
"    endcase" (format nil "~%endmodule~%")))

      ;; ================================================================
      ;; Test 3: for_fromto
      ;; ================================================================
      (run-one "for_fromto"
        (list
          '(:module _$_ nil
            (:integer i j)
            (:for (i 0) (:< i (:<< 1 8)) (i (:+ i 1))
              (:$ display i))
            (:for (j 0) (:< j (:<< 1 8)) (j (:+ j 1))
              (:$ display j))))
        (concatenate 'string
(format nil "~%module _$_;~%")
(format nil "    integer i;~%")
(format nil "    integer j;~%")
(format nil "    for (i = 0; (i < (1 << 8)); i = (i + 1))~%")
(format nil "    begin~%")
(format nil "        $display(i);~%")
(format nil "    end~%")
(format nil "    for (j = 0; (j < (1 << 8)); j = (j + 1))~%")
(format nil "    begin~%")
(format nil "        $display(j);~%")
"    end" (format nil "~%endmodule~%")))

      ;; ================================================================
      ;; Test 4: function_task
      ;; ================================================================
      (run-one "function_task"
        (list
          '(:function (1 2) myfunc (a (2 b c) d)
            (:assign (:cat a b) (:cat c d)))
          '(:function nil myfunc (a (2 b c) d)
            (:assign (:cat a b) (:cat c d)))
          '(:task myfunc
            ((output a b)
             (input c d))
            (:assign (:cat a b) (:cat c d))))
        (concatenate 'string
(format nil "~%function [1 : 2] myfunc;~%")
(format nil "    input a;~%")
(format nil "    input [1 : 0] b;~%")
(format nil "    input [1 : 0] c;~%")
(format nil "    input d;~%")
(format nil "begin~%")
(format nil "    assign {a, b} = {c, d};~%")
(format nil "end~%")
(format nil "endfunction~%")
(format nil "function myfunc;~%")
(format nil "    input a;~%")
(format nil "    input [1 : 0] b;~%")
(format nil "    input [1 : 0] c;~%")
(format nil "    input d;~%")
(format nil "begin~%")
(format nil "    assign {a, b} = {c, d};~%")
(format nil "end~%")
(format nil "endfunction~%")
(format nil "task myfunc;~%")
(format nil "    output a;~%")
(format nil "    output b;~%")
(format nil "    input c;~%")
(format nil "    input d;~%")
(format nil "begin~%")
(format nil "    assign {a, b} = {c, d};~%")
(format nil "end~%")
"endtask"))

      ;; ================================================================
      ;; Test 5: primitive
      ;; ================================================================
      (run-one "primitive"
        (list
          '(:primitive dff
            ((output q)
             (input clk d))
            (:initial
              (:= q 0))
            (:table
              ((r 0) 0)
              ((r 1) 1)
              ((* ?) -))))
        (concatenate 'string
(format nil "~%primitive dff(q, clk, d);~%")
(format nil "    output q;~%")
(format nil "    input clk;~%")
(format nil "    input d;~%")
(format nil "    initial~%")
(format nil "    begin~%")
(format nil "        q = 0;~%")
(format nil "    end~%")
(format nil "    table~%")
(format nil "        r 0 : 0;~%")
(format nil "        r 1 : 1;~%")
(format nil "        * ? : -;~%")
(format nil "    endtable~%")
"endprimitive" (string #\Newline)))

      ;; ================================================================
      ;; Test 6: primitives (26 gate instances)
      ;; ================================================================
      (run-one "primitives"
        (list
          '(:module _$_ nil
            (:inst and anon_0 c_and_d c d)
            (:inst buf anon_1 h2 h)
            (:inst bufif0 anon_2 out in ctl)
            (:inst bufif1 anon_3 out in ctl)
            (:inst cmos anon_4 out in nctl pctl)
            (:inst nand anon_5 d_nand_e d e)
            (:inst nmos anon_6 out in ctl)
            (:inst nor anon_7 e_nor_f e f)
            (:inst not anon_8 a_bar a)
            (:inst notif0 anon_9 out in ctl)
            (:inst notif1 anon_10 out in ctl)
            (:inst or anon_11 b_or_c b c)
            (:inst pmos anon_12 out in ctl)
            (:inst pulldown anon_13 out)
            (:inst pullup anon_14 out)
            (:inst rcmos anon_15 out in nctl pctl)
            (:inst rnmos anon_16 out in ctl)
            (:inst rpmos anon_17 out in ctl)
            (:inst rtran anon_18 io io)
            (:inst rtranif0 anon_19 out in ctl)
            (:inst rtranif1 anon_20 out in ctl)
            (:inst tran anon_21 io io)
            (:inst tranif0 anon_22 out in ctl)
            (:inst tranif1 anon_23 out in ctl)
            (:inst xnor anon_24 g_xnor_h g h)
            (:inst xor anon_25 f_xor_g f g)))
        (concatenate 'string
(format nil "~%module _$_;~%")
(format nil "    and anon_0 (c_and_d, c, d);~%")
(format nil "    buf anon_1 (h2, h);~%")
(format nil "    bufif0 anon_2 (out, in, ctl);~%")
(format nil "    bufif1 anon_3 (out, in, ctl);~%")
(format nil "    cmos anon_4 (out, in, nctl, pctl);~%")
(format nil "    nand anon_5 (d_nand_e, d, e);~%")
(format nil "    nmos anon_6 (out, in, ctl);~%")
(format nil "    nor anon_7 (e_nor_f, e, f);~%")
(format nil "    not anon_8 (a_bar, a);~%")
(format nil "    notif0 anon_9 (out, in, ctl);~%")
(format nil "    notif1 anon_10 (out, in, ctl);~%")
(format nil "    or anon_11 (b_or_c, b, c);~%")
(format nil "    pmos anon_12 (out, in, ctl);~%")
(format nil "    pulldown anon_13 (out);~%")
(format nil "    pullup anon_14 (out);~%")
(format nil "    rcmos anon_15 (out, in, nctl, pctl);~%")
(format nil "    rnmos anon_16 (out, in, ctl);~%")
(format nil "    rpmos anon_17 (out, in, ctl);~%")
(format nil "    rtran anon_18 (io, io);~%")
(format nil "    rtranif0 anon_19 (out, in, ctl);~%")
(format nil "    rtranif1 anon_20 (out, in, ctl);~%")
(format nil "    tran anon_21 (io, io);~%")
(format nil "    tranif0 anon_22 (out, in, ctl);~%")
(format nil "    tranif1 anon_23 (out, in, ctl);~%")
(format nil "    xnor anon_24 (g_xnor_h, g, h);~%")
(format nil "    xor anon_25 (f_xor_g, f, g);~%")
"endmodule" (string #\Newline)))

      ;; ================================================================
      ;; Test 7: module
      ;; ================================================================
      (run-one "module"
        (list
          ;; module test(a, b, c, d, e); with directions and widths
          '(:module test
            ((output a)
             (inout (2 b c))
             (input d e))
            (:$ display b c d e))

          ;; module test2(); — empty port list (not nil)
          '(:module test2
            :empty
            (:wire a b0 b1 d_ c0 c1 e)
            (:inst test anon_0
              a
              (:cat b0 b1)
              (:named-arg d d_)
              (:named-arg c (:cat c0 c1))
              e)
            (:$ display 2))

          ;; module clock(clk); — always with empty sensitivity
          '(:module clock
            ((output clk))
            (:always ()
              (:= clk (:! clk))))

          ;; module test(clk); — always with posedge, non-blocking, cat, ref
          '(:module test
            ((input clk))
            (:reg (3 HD_valid_r))
            (:reg HD_valid)
            (:always ((posedge clk))
              (:<= HD_valid_r (:cat (:ref HD_valid_r 1 0) HD_valid)))))
        (concatenate 'string
(format nil "~%module test(a, b, c, d, e);~%")
(format nil "    output a;~%")
(format nil "    inout [1 : 0] b;~%")
(format nil "    inout [1 : 0] c;~%")
(format nil "    input d;~%")
(format nil "    input e;~%")
(format nil "    $display(b, c, d, e);~%")
"endmodule" (format nil "~%")
(format nil "~%module test2();~%")
(format nil "    wire a;~%")
(format nil "    wire b0;~%")
(format nil "    wire b1;~%")
(format nil "    wire d_;~%")
(format nil "    wire c0;~%")
(format nil "    wire c1;~%")
(format nil "    wire e;~%")
(format nil "    test anon_0 (a, {b0, b1}, .d(d_), .c({c0, c1}), e);~%")
(format nil "    $display(2);~%")
"endmodule" (format nil "~%")
(format nil "~%module clock(clk);~%")
(format nil "    output clk;~%")
(format nil "    always~%")
(format nil "    begin~%")
(format nil "        clk = (!clk);~%")
(format nil "    end~%")
"endmodule" (format nil "~%")
(format nil "~%module test(clk);~%")
(format nil "    input clk;~%")
(format nil "    reg [2 : 0] HD_valid_r;~%")
(format nil "    reg HD_valid;~%")
(format nil "    always~%")
(format nil "        @(posedge clk)~%")
(format nil "    begin~%")
(format nil "        HD_valid_r <= {HD_valid_r[1 : 0], HD_valid};~%")
(format nil "    end~%")
"endmodule" (string #\Newline)))

      ;; ================================================================
      ;; Test 8: assign
      ;; ================================================================
      (run-one "assign"
        (list
          ;; assign x = 4'b0000; — top level (outside module, so we emit directly)
          '(:assign x |4'b0000|)
          ;; module sim_count
          '(:module sim_count
            ((input clk)
             (input debug_v))
            (:reg (16 count))
            (:reg debug_v_d)
            ;; assign debug_v_d = 4'h14D;  (format t result is literal in AST)
            (:assign debug_v_d |4'h14D|)
            (:always ((posedge clk))
              (:if (:<=_op debug_v (:+ |16'h1234| (:h 16 #x1234)))
                (:progn
                  (:<=# debug_v_d debug_v 1 nil)
                  (:<= debug_v_d debug_v))))))
        (concatenate 'string
(format nil "~%assign x = 4'b0000;~%")
"module sim_count(clk, debug_v);" (format nil "~%")
(format nil "    input clk;~%")
(format nil "    input debug_v;~%")
(format nil "    reg [15 : 0] count;~%")
(format nil "    reg debug_v_d;~%")
(format nil "    assign debug_v_d = 4'h14D;~%")
(format nil "    always~%")
(format nil "        @(posedge clk)~%")
(format nil "    begin~%")
(format nil "        if ((debug_v <= (16'h1234 + 16'h1234)))~%")
(format nil "        begin~%")
(format nil "            debug_v_d <= #1 debug_v;~%")
(format nil "            debug_v_d <= debug_v;~%")
(format nil "        end~%")
(format nil "    end~%")
"endmodule" (string #\Newline)))

      ;; ================================================================
      ;; Test 9: dollars_backticks
      ;; ================================================================
      (run-one "dollars_backticks"
        (list
          '(:include "a.v")
          '(:define a 1)
          '(:timescale |1s|)
          '(:module _$_ nil
            (:$ bitstoreal)
            (:$ countdrivers)
            (:$ display)
            (:$ displayb)
            (:$ displayh)
            (:$ displayo)
            (:initial
              (:$ dumpfile "a.vcd")
              (:$ dumpvars))
            (:$ dumpall)
            (:$ dumpfile "a.vcd")
            (:$ dumpflush)
            (:$ dumplimit)
            (:$ dumpoff)
            (:$ dumpon)
            (:$ dumpvar a b)
            (:$ dumpvars)
            (:$ fclose)
            (:$ fdisplay)
            (:$ fdisplayb)
            (:$ fdisplayh)
            (:$ fdisplayo)
            (:$ finish)
            (:$ fmonitor)
            (:$ fmonitorb)
            (:$ fmonitorh)
            (:$ fmonitoro)
            (:$ fopen)
            (:$ fstrobe)
            (:$ fstrobeb)
            (:$ fstrobeh)
            (:$ fstrobeo)
            (:$ fwrite)
            (:$ fwriteb)
            (:$ fwriteh)
            (:$ fwriteo)
            (:$ getpattern)
            (:$ hold)
            (:$ incsave)
            (:$ itor)
            (:$ key)
            (:$ list)
            (:$ log)
            (:$ monitor)
            (:$ monitorb)
            (:$ monitorh)
            (:$ monitoro)
            (:$ monitoroff)
            (:$ monitoron)
            (:$ nokey)
            (:$ nolog)
            (:$ period)
            (:$ printtimescale)
            (:$ random)
            (:$ readmemb)
            (:$ readmemh)
            (:$ realtobits)
            (:$ recovery)
            (:$ reset)
            (:$ reset_count)
            (:$ reset_value)
            (:$ restart)
            (:$ rtoi)
            (:$ save)
            (:$ scale)
            (:$ scope)
            (:$ setup)
            (:$ setuphold)
            (:$ showscopes)
            (:$ showvars)
            (:$ skew)
            (:$ sreadmemb)
            (:$ sreadmemh)
            (:$ stop)
            (:$ strobe)
            (:$ strobeb)
            (:$ strobeh)
            (:$ strobeo)
            (:$ timeformat)
            (:$ width)
            (:$ write)
            (:$ writeb)
            (:$ writeh)
            (:$ writeo)
            (:$ display (:$var realtime))
            (:$ display (:$var time))
            (:$ display (:$var stime))))
        (concatenate 'string
(format nil "~%`include \"a.v\"~%")
(format nil "`define a 1~%")
(format nil "`timescale 1s~%")
"module _$_;" (format nil "~%")
(format nil "    $bitstoreal;~%")
(format nil "    $countdrivers;~%")
(format nil "    $display;~%")
(format nil "    $displayb;~%")
(format nil "    $displayh;~%")
(format nil "    $displayo;~%")
(format nil "    initial~%")
(format nil "    begin~%")
(format nil "        $dumpfile(\"a.vcd\");~%")
(format nil "        $dumpvars;~%")
(format nil "    end~%")
(format nil "    $dumpall;~%")
(format nil "    $dumpfile(\"a.vcd\");~%")
(format nil "    $dumpflush;~%")
(format nil "    $dumplimit;~%")
(format nil "    $dumpoff;~%")
(format nil "    $dumpon;~%")
(format nil "    $dumpvar(a, b);~%")
(format nil "    $dumpvars;~%")
(format nil "    $fclose;~%")
(format nil "    $fdisplay;~%")
(format nil "    $fdisplayb;~%")
(format nil "    $fdisplayh;~%")
(format nil "    $fdisplayo;~%")
(format nil "    $finish;~%")
(format nil "    $fmonitor;~%")
(format nil "    $fmonitorb;~%")
(format nil "    $fmonitorh;~%")
(format nil "    $fmonitoro;~%")
(format nil "    $fopen;~%")
(format nil "    $fstrobe;~%")
(format nil "    $fstrobeb;~%")
(format nil "    $fstrobeh;~%")
(format nil "    $fstrobeo;~%")
(format nil "    $fwrite;~%")
(format nil "    $fwriteb;~%")
(format nil "    $fwriteh;~%")
(format nil "    $fwriteo;~%")
(format nil "    $getpattern;~%")
(format nil "    $hold;~%")
(format nil "    $incsave;~%")
(format nil "    $itor;~%")
(format nil "    $key;~%")
(format nil "    $list;~%")
(format nil "    $log;~%")
(format nil "    $monitor;~%")
(format nil "    $monitorb;~%")
(format nil "    $monitorh;~%")
(format nil "    $monitoro;~%")
(format nil "    $monitoroff;~%")
(format nil "    $monitoron;~%")
(format nil "    $nokey;~%")
(format nil "    $nolog;~%")
(format nil "    $period;~%")
(format nil "    $printtimescale;~%")
(format nil "    $random;~%")
(format nil "    $readmemb;~%")
(format nil "    $readmemh;~%")
(format nil "    $realtobits;~%")
(format nil "    $recovery;~%")
(format nil "    $reset;~%")
(format nil "    $reset_count;~%")
(format nil "    $reset_value;~%")
(format nil "    $restart;~%")
(format nil "    $rtoi;~%")
(format nil "    $save;~%")
(format nil "    $scale;~%")
(format nil "    $scope;~%")
(format nil "    $setup;~%")
(format nil "    $setuphold;~%")
(format nil "    $showscopes;~%")
(format nil "    $showvars;~%")
(format nil "    $skew;~%")
(format nil "    $sreadmemb;~%")
(format nil "    $sreadmemh;~%")
(format nil "    $stop;~%")
(format nil "    $strobe;~%")
(format nil "    $strobeb;~%")
(format nil "    $strobeh;~%")
(format nil "    $strobeo;~%")
(format nil "    $timeformat;~%")
(format nil "    $width;~%")
(format nil "    $write;~%")
(format nil "    $writeb;~%")
(format nil "    $writeh;~%")
(format nil "    $writeo;~%")
(format nil "    $display($realtime);~%")
(format nil "    $display($time);~%")
(format nil "    $display($stime);~%")
"endmodule" (string #\Newline)))

    ) ;; end flet

    (format t "~a successes, ~a failures~%" successes failures)
    failures))
